<?php
// $Id$

// Copyright 2008-2009 Jonathan Brown


define('STORAGE_API_STORAGE_ONLY', 0);
define('STORAGE_API_SERVING', 1);
define('STORAGE_API_ACCESS_CONTROL', 2);

$path = drupal_get_path('module', 'storage_api');
require_once DRUPAL_ROOT . '/' . $path . '/instance_operations.inc';


/**
 * Implement hook_permission() .
 */
function storage_api_permission() {

  return array('administer storage' => array(
    'title' => t('Administer storage'),
//    'description' => t(''),
  ));
}


/**
 * Implement hook_menu() .
 */
function storage_api_menu() {

  $items['system/storage_api/serve/%storage_api_file'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'storage_api_serve',
    'page arguments' => array(3),
    'access callback' => 'storage_api_serve_access',
    'access arguments' => array(3)
  );
  

  $items['admin/config/media/storage'] = array(
    'title' => 'Storage',
    'access arguments' => array('administer storage'),
    'description' => 'Configure storage.',
    'page callback' => 'system_admin_menu_block_page',
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system')
  );


  $items['admin/config/media/storage/services'] = array(
    'title' => 'Services',
    'description' => 'Configure storage services.',
    'access arguments' => array('administer storage'),
    'page callback' => 'storage_api_services',
    'weight' => 0,
    'file' => 'services.admin.inc'
  );
  
  $items['admin/config/media/storage/services/%storage_api_service'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_service_form', 5),
    'file' => 'services.admin.inc',
  );
  
  $items['admin/config/media/storage/services/%storage_api_service/suspend'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_service_suspend_form', 5),
    'file' => 'services.admin.inc'
  );
  
  $items['admin/config/media/storage/services/%storage_api_service/unsuspend'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_service_unsuspend_form', 5),
    'file' => 'services.admin.inc'
  );
  
  
  $items['admin/config/media/storage/containers'] = array(
    'title' => 'Containers',
    'description' => 'Configure storage containers.',
    'access arguments' => array('administer storage'),
    'page callback' => 'storage_api_containers',
    'weight' => 1,
    'file' => 'containers.admin.inc'
  );

  $items['admin/config/media/storage/containers/list'] = array(
    'title' => 'Overview',
    'access arguments' => array('administer storage'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
    'file' => 'containers.admin.inc'
  );
  
  $items['admin/config/media/storage/containers/create'] = array(
    'title' => 'Create',
    'access arguments' => array('administer storage'),
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_create_container_form'),
    'weight' => 1,
    'file' => 'containers.admin.inc'
  );
  
  $items['admin/config/media/storage/containers/%storage_api_container'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_container_form', 5),
    'file' => 'containers.admin.inc'
  );
  
  $items['admin/config/media/storage/containers/%storage_api_container/view'] = array(
    'title' => 'View',
    'access arguments' => array('administer storage'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
    'file' => 'containers.admin.inc'
  );
  
  $items['admin/config/media/storage/containers/%storage_api_container/suspend'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_container_suspend_form', 5),
    'file' => 'containers.admin.inc',
  );
  
  $items['admin/config/media/storage/containers/%storage_api_container/unsuspend'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_container_unsuspend_form', 5),
    'file' => 'containers.admin.inc'
  );
  
  $items['admin/config/media/storage/containers/%storage_api_container/drain'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_container_drain_form', 5),
    'file' => 'containers.admin.inc'
  );

  $items['admin/config/media/storage/containers/%storage_api_container/destroy'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_container_destroy_form', 5),
    'file' => 'containers.admin.inc'
  );
  
  $items['admin/config/media/storage/containers/%storage_api_container/edit'] = array(
    'title' => 'Edit',
    'access arguments' => array('administer storage'),
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_container_edit_form', 5),
    'weight' => 1,
    'file' => 'containers.admin.inc'
  );

  
  $items['admin/config/media/storage/classes'] = array(
    'title' => 'Classes',
    'description' => 'Configure storage classes.',
    'access arguments' => array('administer storage'),
    'page callback' => 'storage_api_classes_list',
    'weight' => 2,
    'file' => 'classes.admin.inc'
  );

  $items['admin/config/media/storage/classes/list'] = array(
    'title' => 'Overview',
    'access arguments' => array('administer storage'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
    'file' => 'classes.admin.inc'
  );

  $items['admin/config/media/storage/classes/create'] = array(
    'title' => 'Create',
    'access arguments' => array('administer storage'),
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_create_class_form'),
    'weight' => 1,
    'file' => 'classes.admin.inc'
  );

  $items['admin/config/media/storage/classes/%storage_api_class'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'storage_api_class',
    'page arguments' => array(5),
    'file' => 'classes.admin.inc'
  );
  
  $items['admin/config/media/storage/classes/%storage_api_class/view'] = array(
    'title' => 'View',
    'access arguments' => array('administer storage'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
    'file' => 'classes.admin.inc'
  );
  
  $items['admin/config/media/storage/classes/%storage_api_class/edit'] = array(
    'title' => 'Edit',
    'access arguments' => array('administer storage'),
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_class_edit_form', 5),
    'weight' => 1,
    'file' => 'classes.admin.inc'
  );
  
  $items['admin/config/media/storage/classes/%storage_api_class/destroy'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_class_destroy_form', 5),
    'file' => 'classes.admin.inc'
  );
  
  $items['admin/config/media/storage/classes/%storage_api_class/add'] = array(
    'title' => 'Add container',
    'access arguments' => array('administer storage'),
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_class_add_container_form', 5),
    'weight' => 2,
    'file' => 'classes.admin.inc'
  );
  
  $items['admin/config/media/storage/classes/%storage_api_class/remove/%storage_api_container'] = array(
    'title' => 'Remove container',
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_api_class_remove_container_form', 5, 7),
    'file' => 'classes.admin.inc'
  );

  return $items;
}


$_storage_api_file_cache = array();

function storage_api_file_flush($file_id = NULL) {
  global $_storage_api_file_cache;
  
  if($file_id)
    unset($_storage_api_file_cache[$file_id]);
  else
    unset($_storage_api_file_cache);
}


/**
 * Loads a file.
 *
 * @param $file_id
 *   The file_id of the file to be loaded.
 * @param $reload
 *   Boolean If TRUE, reload the file from the database, instead of returning a cached copy.
 * @return
 *   The file.
 */
function storage_api_file_load($file_id, $reload = FALSE) {
  global $_storage_api_file_cache;

  if(!$file_id)
    return FALSE;
  
  if(!$reload) {
  
    if($_storage_api_file_cache[$file_id])
      return $_storage_api_file_cache[$file_id];
  }
  
  // either the file is being deleted and no longer has a selector,
  // or we grab the selector with migrating = 0

  $query = db_select('storage_file');
  $query->leftJoin('storage_object', NULL, 'storage_file.object_id = storage_object.object_id');
  $query->leftJoin('storage_selector', NULL, 'storage_file.selector_id = storage_selector.selector_id');
  $query->leftJoin('storage_class', NULL, 'storage_selector.class_id = storage_class.class_id');
  
  $file = $query->fields('storage_file')
    ->fields('storage_object')
    ->fields('storage_selector')
    ->fields('storage_class')
    ->condition('storage_file.file_id', $file_id)
    ->condition(db_or()->isNull('storage_file.selector_id')->condition('storage_selector.migrating', 0))
    ->execute()
    ->fetchAssoc();
  
  if(!$file)
    return FALSE;
  
  $file['data'] = unserialize($file['data']);
  $file['options'] = unserialize($file['options']);
  
  if($file['serving_container'])
    $file['serving_container'] = unserialize($file['serving_container']);
  
  $_storage_api_file_cache[$file_id] = $file;
  
  return $file;
}


/**
 * Loads a storage service.
 *
 * @param $srvice_id
 *   The service_id of the service to be loaded.
 * @return
 *   The service.
 */
function storage_api_service_load($service_id) {

  if(!$service_id)
    return FALSE;

  $service = db_select('storage_service')
    ->fields('storage_service')
    ->condition('service_id', $service_id)
    ->execute()
    ->fetchAssoc();
    
  if(!$service)
    return FALSE;
  
  $info = _storage_api_service_invoke($service_id, 'service_info');
  
  return $service + $info;
}


/**
 * Loads a storage container.
 *
 * @param $container_id
 *   The container_id of the container to be loaded.
 * @return
 *   The container.
 */
function storage_api_container_load($container_id) {

  if(!$container_id)
    return FALSE;
    
  $container = db_select('storage_container')
    ->fields('storage_container')
    ->condition('container_id', $container_id)
    ->execute()
    ->fetchAssoc();
  
  if(!$container)
    return FALSE;
  
  $container['settings'] = unserialize($container['settings']);

  return $container;
}


/**
 * Loads a storage class.
 *
 * @param $class_id
 *   The class_id of the class to be loaded.
 * @return
 *   The class.
 */
function storage_api_class_load($class_id) {

  if(!$class_id)
    return FALSE;
    
  $class = db_select('storage_class')
    ->fields('storage_class')
    ->condition('class_id', $class_id)
    ->execute()
    ->fetchAssoc();

  if(!$class)
    return FALSE;
  
  $class['options'] = unserialize($class['options']);
  
  return $class;
}


function _storage_api_update_services() {

  $modules = module_implements('storage_service_info');

  $code_service_ids = array();

  foreach($modules as $module)
    $code_service_ids[] = substr($module, 8);


  $result = db_select('storage_service', NULL, array('fetch' => PDO::FETCH_ASSOC))
    ->fields('storage_service', array('service_id'))
    ->execute();

  $db_service_ids = array();

  foreach($result as $service) {

    if(!in_array($service['service_id'], $code_service_ids)) {

      db_delete('storage_service')
        ->condition('service_id', $service['service_id'])
        ->execute();
    }
    else {
      $db_service_ids[] = $service['service_id'];
    }
  }
  
  
  foreach($code_service_ids as $service_id) {
  
    if(!in_array($service_id, $db_service_ids)) {
    
      $service = array('service_id' => $service_id);
      drupal_write_record('storage_service', $service);
    }
  }
}  


function _storage_api_service_invoke() {
  $args = func_get_args();
  
  $module = 'storage_' . array_shift($args);
  $hook = 'storage_' . array_shift($args);
  
  if(module_hook($module, $hook))
    return call_user_func_array($module . '_' . $hook, $args);
  else
    return $args[0];
}


function _storage_api_service_invoke_all() {
  $results = array();
  
  $args = func_get_args();
  array_unshift($args, NULL);
  $args[1] = 'storage_' . $args[1];
  
  foreach(module_implements($args[1], TRUE) as $module) {
    $args[0] = $module;
    $results[substr($module, 8)] = call_user_func_array('module_invoke', $args);
  }
  
  return $results;
}


function _storage_api_get_service_names() {

  $services = _storage_api_service_invoke_all('service_info');
  
  foreach($services as &$service)
    $service = $service['name'];
    
  asort($services);
  
  return $services;
}


function _storage_api_get_service_name($service_id, $link = FALSE) {

  $info = _storage_api_service_invoke($service_id, 'service_info');
  
  if($link)
    return l($info['name'], 'admin/config/media/storage/services/' . $service_id);
  else
    return $info['name'];
}


function _storage_api_log_serving($file, $container_id = NULL) {
  global $user;
  
  $serving = array(
    'file_id' => $file['file_id'],
    'size' => $file['size'],
    'uid' => $user->uid,
    'sid' => session_id(),
    'ip_addr' => ip2long(ip_address()),
    'timestamp' => REQUEST_TIME,
    'referrer' => substr($_SERVER['HTTP_REFERER'], 0, 255)
  );
  
  if($container_id) {
    $serving['container_id'] = $container_id;
  }

  drupal_write_record('storage_serving', $serving);
  
  db_update('storage_file')
    ->fields(array('last_touched' => REQUEST_TIME))
    ->expression('servings', 'servings + :one', array(':one' => 1))   // apparently literals can't be in fragments
    ->condition('file_id', $file['file_id'])
    ->execute();
}


function _storage_api_file_touch($file) {

  $update = array(
    'file_id' => $file['file_id'],
    'last_touched' => REQUEST_TIME,
  );

  drupal_write_record('storage_file', $update, 'file_id');
}


/**
 * Determine whether the user has access to a file.
 *
 * @param $file
 *   The file that access is being checked for.
 * @return
 *   Boolean TRUE if the current user has access to the file.
 */
function storage_api_serve_access($file) {

  if(!$file['options']['access_control'])
    return TRUE;

  $results = module_invoke_all('storage_access_alter', $file['module'], $file['type'], $file['file_id']);
  
  foreach($results as $result) {
  
    if(isset($result))
      return $result;
  }
  
  if($file['module']) {
  
    $result = module_invoke($file['module'], 'storage_access', $file['type'], $file['file_id']);
    
    if(isset($result))
      return $result;
  }
  
  if($file['nid']) {
  
    return node_access('view', node_load($file['nid']));
  }
  
  return TRUE;
}


function _storage_api_service_unavailable() {
  drupal_add_http_header('503 Service Unavailable');
  watchdog('service unavailable', check_plain($_GET['q']), NULL, WATCHDOG_WARNING);

  // Keep old path for reference.
  if (!isset($_REQUEST['destination'])) {
    $_REQUEST['destination'] = $_GET['q'];
  }

  $path = drupal_get_normal_path(variable_get('site_503', ''));
  if ($path && $path != $_GET['q']) {
    // Custom 503 handler. Set the active item in case there are tabs to
    // display, or other dependencies on the path.
    menu_set_active_item($path);
    $return = menu_execute_active_handler($path, FALSE);
  }

  if (empty($return) || $return == MENU_NOT_FOUND || $return == MENU_ACCESS_DENIED) {
    drupal_set_title(t('Service unavailable'), PASS_THROUGH);
    $return = t('The requested page is not currently available.');
  }
  
  print drupal_render_page($return);
}


function _storage_api_serving_container($file) {

  $objects_subquery = db_select('storage_object_instance');
  $objects_subquery->join('storage_class_container', NULL, 'storage_object_instance.container_id = storage_class_container.container_id');
  $objects_subquery->join('storage_selector', NULL, 'storage_class_container.class_id = storage_selector.class_id');
  $objects_subquery->join('storage_container', NULL, 'storage_object_instance.container_id = storage_container.container_id');
  $objects_subquery->join('storage_service', NULL, 'storage_object_instance.service_id = storage_service.service_id');
  
  $objects_subquery->condition('storage_object_instance.object_id', $file['object_id'])
    ->condition('storage_class_container.serving', 1, '>=')
    ->condition('storage_selector.selector_id', $file['selector_id'])
    ->condition('storage_container.suspended', 0)
    ->condition('storage_service.suspended', 0)
    ->fields('storage_container')
    ->fields('storage_class_container', array('weight'))
    ->fields('storage_selector', array('migrating'));
    
  $objects_subquery->addExpression('\'object\'', 'type');


  $files_subquery = db_select('storage_file_instance');
  $files_subquery->join('storage_class_container', NULL, 'storage_file_instance.container_id = storage_class_container.container_id');
  $files_subquery->join('storage_selector', NULL, 'storage_class_container.class_id = storage_selector.class_id');
  $files_subquery->join('storage_container', NULL, 'storage_file_instance.container_id = storage_container.container_id');
  $files_subquery->join('storage_service', NULL, 'storage_file_instance.service_id = storage_service.service_id');
  
  $files_subquery->condition('storage_file_instance.file_id', $file['file_id'])
    ->condition('storage_class_container.serving', 1, '>=')
    ->condition('storage_selector.selector_id', $file['selector_id'])
    ->condition('storage_container.suspended', 0)
    ->condition('storage_service.suspended', 0)
    ->fields('storage_container')
    ->fields('storage_class_container', array('weight'))
    ->fields('storage_selector', array('migrating'));

  $files_subquery->addExpression('\'file\'', 'type');
    
  $container = $objects_subquery->union($files_subquery, 'ALL')
    ->orderBy('migrating')
    ->orderBy('weight')
    ->orderBy('container_id')
    ->range(0, 1)
    ->execute()
    ->fetchAssoc();
  
  if(!$container)
    return FALSE;

  $container['settings'] = unserialize($container['settings']);
  return $container;
}


function _storage_api_cache_serving_container($file_id, $container) {

  db_update('storage_file')
    ->fields(array('serving_container' => serialize($container)))
    ->condition('file_id', $file_id)
    ->execute();

  storage_api_file_flush($file_id);
}


function _storage_api_flush_serving_container($file_id) {

  db_update('storage_file')
    ->expression('serving_container', 'NULL')
    ->condition('file_id', $file_id)
    ->execute();

  storage_api_file_flush($file_id);
}


function _storage_api_container_flush_serving_container($container_id) {

  $selector_subquery = db_select('storage_class_container');
  $selector_subquery->join('storage_selector', NULL, 'storage_class_container.class_id = storage_selector.class_id');
    
  $selector_subquery->fields('storage_selector', array('selector_id'))
    ->condition('storage_class_container.container_id', $container_id);
    
  db_update('storage_file')
    ->expression('serving_container', 'NULL')
    ->condition('selector_id', $selector_subquery, 'IN')
    ->execute();

  cache_clear_all();
}


function _storage_api_file_generate(&$file) {

  $container = _storage_api_get_initial_container($file['selector_id']);
  
  if(!$container)
    return FALSE;

  $filepath = storage_api_get_local_filepath($file, $keep_me);
  
  if(!$filepath)
    return FALSE;
    
  $file['filepath'] = $filepath;
  $file['keep_me'] = $keep_me;
  
  if(!_storage_api_create_instance($container, $file)) {

    $message = 'Failed to create instance of file ' . ($file['filename'] ? ($file['filename'] . ' ') : '');
    $message .= 'in storage container <i>' . $container['name'] . '</i>.';
    $message .= ' <br />' . _storage_api_file_log_info($file);
    watchdog('storage_api', $message, NULL, WATCHDOG_WARNING, $link);

    return FALSE;
  }
  
  $message = 'Generated file' . ($file['filename'] ? (' ' . $file['filename']) : '');
  $message .= '<br />' . _storage_api_file_log_info($file);
  watchdog('storage_api', $message, NULL, WATCHDOG_NOTICE, $link);

  return $container;
}


/**
 * Serve the specified file, either directly or by an HTTP 302 redirect.
 *
 * @param $file
 *   The file that is to be served.
 */
function storage_api_serve($file) {

  if($file['serving_container']) {
    $container = $file['serving_container'];
  }
  else {
    $container = _storage_api_serving_container($file);
  
    if(!$container)
      $container = _storage_api_file_generate($file);
      
    _storage_api_cache_serving_container($file['file_id'], $container);
  }
  
  if($container) {
    _storage_api_log_serving($file, $container['container_id']);
    
    switch($container['type']) {
    
      case 'object':    // this may not return
        $url = _storage_api_service_invoke($container['service_id'], 'object_instance_serve', 
          $container, $file);
        break;
      
      case 'file':      // this will definitely return
        $url = _storage_api_service_invoke($container['service_id'], 'file_instance_serve',
          $container, $file);
        break;
    }
  }
  else if($file['options']['serve_source_url'] && $file['source_url']) {

    _storage_api_log_serving($file);
    $url = $file['source_url'];
  }
  
  if(!$url) {
    _storage_api_service_unavailable();
    return;
  }
  
  // this will definitely not return
  drupal_goto($url);    // 302 redirect (don't cache)
}


function _storage_api_serve_path($file) {
  
  return 'system/storage_api/serve/' . $file['file_id'] . ($file['filename'] ? ('/' . $file['filename']) : '');
}


/**
 * Generates a URL that will serve the supplied file.
 *
 * If the files's class is set to serve by redirection, then the URL will be on your site. Otherwise, Storage API will determine which container to serve from and generate a direct URL.
 *
 * @param $file
 *   The file to be served. Returned from storage_api_file_load() .
 * @param $absolute
 *   Whether the generated URL should be absolute.
 * @return
 *   The generated URL.
 */
function storage_api_serve_url($file, $absolute = FALSE) {
  
  if(!$file || $file['serving_container'] === FALSE || $file['options']['redirect']) {  // FALSE means there is no container
    $serve_from_site = TRUE;
  }
  else if(!storage_api_serve_access($file)) {
    $serve_from_site = TRUE;
  }
  
  if($serve_from_site)
    return url(_storage_api_serve_path($file), array('absolute' => $absolute));


  if($file['serving_container']) {
    $container = $file['serving_container'];
  }
  else {
    $container = _storage_api_serving_container($file);

    _storage_api_cache_serving_container($file['file_id'], $container);
  }
  
  if($container) {
    $info = _storage_api_service_invoke($container['service_id'], 'service_info');
    
    if(!$info['direct']) {    // direct services don't return a URL
    
      switch($container['type']) {
      
        case 'object':
          $url = _storage_api_service_invoke($container['service_id'], 'object_instance_serve', 
            $container, $file);
          break;
        
        case 'file':
          $url = _storage_api_service_invoke($container['service_id'], 'file_instance_serve',
            $container, $file);
          break;
      }
    }
  }
  else if($file['options']['serve_source_url'] && $file['source_url']) {

    $url = $file['source_url'];
  }
  
  if(!$url)
    $url = _storage_api_serve_path($file);
  else
    _storage_api_file_touch($file);

  return url($url, array('absolute' => $absolute));
}


/**
 * Creates a new class selector.
 *
 * @return
 *   The selector_id of the new class selector.
 */
function storage_api_new_selector_id() {
  $txn = db_transaction();

  $class_id = db_select('storage_class')
    ->fields('storage_class', array('class_id'))
    ->orderBy('name')
    ->orderBy('class_id')
    ->range(0, 1)
    ->execute()
    ->fetchField();

  $selector = array('class_id' => $class_id);
  drupal_write_record('storage_selector', $selector);
  
  return $selector['selector_id'];
}


/**
 * Generates a FAPI select element for a class selector.
 *
 * After form submission, pass the form value for the element to storage_api_selector_submit() .
 *
 * @param $selector_id
 *   The selector_id of the selector the element is for.
 * @param $title
 *   The title of the select element.
 * @param $description
 *   The description of the select element (optional).
 * @return
 *   The select element.
 */
function storage_api_selector_item($selector_id, $title, $description = NULL) {
  
  $selector = array(
    '#tree' => TRUE
  );
  
  $result = db_select('storage_class', NULL, array('fetch' => PDO::FETCH_ASSOC))
    ->fields('storage_class')
    ->orderBy('name')
    ->orderBy('class_id')
    ->execute();
  
  $classes = array();

  foreach($result as $class) {
    $classes[$class['class_id']] = $class['name'];
  }
  
  $selector['class_id'] = array(
    '#type' => 'select',
    '#title' => $title,
    '#description' => $description,
    '#options' => $classes
  );
  
  $selector['selector_id'] = array(
    '#type' => 'value',
    '#value' => $selector_id
  );

  $current_class_id = db_select('storage_selector')
    ->fields('storage_selector', array('class_id'))
    ->condition('selector_id', $selector_id)
    ->condition('migrating', 0)
    ->execute()
    ->fetchField();

  $selector['class_id']['#default_value'] = $current_class_id;
  
  $selector['current_class_id'] = array(
    '#type' => 'value',
    '#value' => $current_class_id
  );
  
  return $selector;
}


/**
 * Processes a class selector FAPI element.
 *
 * The element's class selector is updated to point at the class selected. Migration of files to the new class is initiated.
 *
 * @param $form_item
 *   The form value of a submitted class selector FAPI element.
 */
function storage_api_selector_submit($form_item) {

  if($form_item['current_class_id'] == $form_item['class_id'])
    return;


  db_merge('storage_selector')
    ->key(array(
      'selector_id' => $form_item['selector_id'],
      'class_id' => $form_item['class_id'],
    ))
    ->fields(array('migrating' => 0))
    ->execute();

  
  // are there any files to migrate?

  $num_files = db_select('storage_file')
    ->condition('selector_id', $form_item['selector_id'])
    ->countQuery()
    ->execute()
    ->fetchField();
  
  if($num_files) {

    db_merge('storage_selector')
      ->key(array(
        'selector_id' => $form_item['selector_id'],
        'class_id' => $form_item['current_class_id'],
      ))
      ->fields(array('migrating' => 1))
      ->execute();

    db_update('storage_file')
      ->fields(array('check_me' => 1))
      ->expression('serving_container', 'NULL')
      ->condition('selector_id', $form_item['selector_id'])
      ->execute();
    
    $new_class = storage_api_class_load($form_item['class_id']);
    
    $message = 'Migrating ' . $num_files . ' ' . format_plural($num_files, 'file', 'files');
    $message .= ' to storage class <i>' . $new_class['name'] . '</i>.';
    
    drupal_set_message($message);
    watchdog('storage_api', $message, NULL);
  }
  else {
  
    db_delete('storage_selector')
      ->condition('service_id', $form_item['service_id'])
      ->condition('class_id', $form_item['current_class_id'])
      ->execute();
  }
}


/**
 * Deletes a class selector.
 *
 * @param $selector_id
 *   The selector_id of the selector to be deleted.
 */
function storage_api_selector_delete($selector_id) {
  
  db_delete('storage_selector')
    ->condition('selector_id', $selector_id)
    ->execute();
}


function _storage_api_get_initial_container($selector_id) {

  // find the container with the lowest priority in the class
  
  $query = db_select('storage_selector');
  $query->join('storage_class_container', NULL, 'storage_selector.class_id = storage_class_container.class_id');
  $query->join('storage_container', NULL, 'storage_class_container.container_id = storage_container.container_id');
  $query->join('storage_service', NULL, 'storage_container.service_id = storage_service.service_id');
  
  $container = $query->fields('storage_container')
    ->condition('storage_selector.selector_id', $selector_id)
    ->condition('storage_selector.migrating', 0)
    ->condition('storage_container.suspended', 0)
    ->condition('storage_service.suspended', 0)
    ->orderBy('storage_class_container.weight', 'DESC')
    ->orderBy('storage_container.container_id', 'DESC')
    ->range(0, 1)
    ->execute()
    ->fetchAssoc();
  
  if(!$container)
    return FALSE;

  $container['settings'] = unserialize($container['settings']);
  
  return $container;
}


function _storage_api_get_object_id($filepath, &$new_object = NULL) {
  $txn = db_transaction();

  $fileinfo = @stat($filepath);
  
  if(!$fileinfo)
    return FALSE;

  $md5 = '0x' . hash_file('md5', $filepath);
  $whirlpool = '0x' . hash_file('whirlpool', $filepath);
  
  $object_id = db_select('storage_object')
    ->fields('storage_object', array('object_id'))
    ->condition('size', $fileinfo['size'])
    ->condition('md5', $md5)
    ->condition('whirlpool', $whirlpool)
    ->execute()
    ->fetchField();

  if(!$object_id) {
  
    $object = array(
      'size' => $fileinfo['size'],
      'md5' => $md5,
      'whirlpool' => $whirlpool,
      'mimetype' => mimedetect_mime(array('filepath' => $filepath)),
    );

    db_write_record('storage_object', $object);

    $object_id = $object['object_id'];
    $new_object = TRUE;
  }
  
  return $object_id;
}


/**
 * Determines if a file's reference already exists in a container.
 *
 * @param $container
 *   The container to check in.
 * @param $reference
 *   The reference to look for.
 * @return
 *   Whether the reference exists in the container.
 */
function storage_api_file_reference_exists($container, $reference) {

  return (bool)db_select('storage_file_instance')
    ->condition('container_id', $container['container_id'])
    ->condition('reference', $reference)
    ->countQuery()
    ->execute()
    ->fetchField();
}


/**
 * Generates a unique filename for a container, based on a desired filename.
 *
 * @param $container
 *   The container the filename should be unique in.
 * @param $filename
 *   Desired filename.
 * @return
 *   Unique filename.
 */
function storage_api_unique_filename($container, $filename) {

  if(storage_api_file_reference_exists($container, $filename)) {

    $pos = strrpos($filename, '.');
    
    if($pos !== FALSE) {
      $name = substr($filename, 0, $pos);
      $ext = substr($filename, $pos);
    }
    else {
      $name = $filename;
    }

    $counter = 0;
    
    do {
      $filename = $name . '_' . $counter++ . $ext;
      
    } while(storage_api_file_reference_exists($container, $filename));
  }

  return $filename;
}


function _storage_api_object_instance_exists($object_id, $container_id) {

  return db_select('storage_object_instance')
    ->fields('storage_object_instance', array('reference'))
    ->condition('object_id', $object_id)
    ->condition('container_id', $container_id)
    ->execute()
    ->fetchAssoc();
}


function _storage_api_file_instance_exists($file_id, $container_id) {

  return db_select('storage_file_instance')
    ->fields('storage_file_instance', array('reference'))
    ->condition('file_id', $file_id)
    ->condition('container_id', $container_id)
    ->execute()
    ->fetchAssoc();
}


/**
 * Transfers serving statistics from one file to another.
 *
 * @param $new_file_id
 *   file_id of the file to receive the statistics.
 * @param $old_file_id
 *   file_id of the file the statistics are being transferred from.
 */
function storage_api_inherit_servings($new_file_id, $old_file_id) {

  if(!$old_file_id)
    return;

  db_update('storage_serving')
    ->fields(array('file_id' => $new_file_id))
    ->condition('file_id', $old_file_id)
    ->execute();

  $old_stats = db_select('storage_file')
    ->fields('storage_file', array('servings', 'last_touched'))
    ->condition('file_id', $old_file_id)
    ->execute()
    ->fetchAssoc();

  db_update('storage_file')
    ->expression('servings', 'servings + :servings', array(':servings' => $old_stats['servings']))
    ->expression('last_touched', 'GREATEST(last_touched, :last_touched)', array(':last_touched' => $old_stats['last_touched']))
    ->condition('file_id', $new_file_id)
    ->execute();
}


/**
 * Adds a file for Storage API to manage.
 *
 * The file will initially be stored in the lowest prioity container that is available in the file's class.
 *
 * @param $selector_id
 *   selector_id of class selector to put the file in.
 * @param $options
 *   An associative array of additional options, with the following keys:
 *     - 'filepath'
 *       Filepath to get the file from.
 *     - 'keep_me' (default FALSE)
 *       Ensure the filepath is left intact.
 *     - 'source_url'
 *       URL to get the file from
 *     - 'filename'
 *       The file's filename.
 *     - 'get_filename' (default FALSE)
 *       Determine the filename from the filepath / source_url.
 *     - 'force_download' (default FALSE)
 *       When a web browser accesses this file, force it to be downloaded.
 *     - 'module'
 *       The Drupal module that 'owns' this file.
 *     - 'type'
 *       Module-specific file type identifier.
 *     - 'nid'
 *       The nid of the node this file should be associated with.
 *     - 'obtained' (default current time)
 *       Unix timestamp of when the file was obtained.
 *     - 'data'
 *       An array of data about the file.
 * @return
 *   file_id of the added file or FALSE for failure.
 */
function storage_api_file_add($selector_id, $options = array()) {
  $options['selector_id'] = $selector_id;
  
  if(!$options['obtained'])
    $options['obtained'] = REQUEST_TIME;

  if($options['filepath']) {
    $container = _storage_api_get_initial_container($selector_id);
    
    if(!$container)
      return FALSE;

    $options['object_id'] = _storage_api_get_object_id($options['filepath'], $new_object);
  }

  if($options['get_filename']) {

    if($options['filepath']) {
      $options['filename'] = basename($options['filepath']);
    }
    else if($options['source_url']) {
      $options['filename'] = basename(parse_url($options['source_url'], PHP_URL_PATH));
    }
  }
  
  $options['check_me'] = TRUE;
  drupal_write_record('storage_file', $options);
  $file = storage_api_file_load($options['file_id']);

  
  $link = $file['nid'] ? l(t('view'), 'node/' . $file['nid']) : NULL;
  
  if($options['filepath']) {
  
    $file['filepath'] = $options['filepath'];
    $file['keep_me'] = $options['keep_me'];
    $file['new_object'] = $new_object;
    
    if(!_storage_api_create_instance($container, $file)) {

      $message = 'Failed to create initial instance of file ' . ($file['filename'] ? ($file['filename'] . ' ') : '');
      $message .= 'in storage container <i>' . $container['name'] . '</i>.';

      if(user_access('administer storage'))
        drupal_set_message($message);

      $message .= ' <br />' . _storage_api_file_log_info($file);
      watchdog('storage_api', $message, NULL, WATCHDOG_WARNING, $link);
      
      storage_api_file_remove($file_id);
      return FALSE;
    }
  }
  
  $message = 'File added' . ($file['filename'] ? (': ' . $file['filename'] . ' ') : '') . ' <br />';
  $message .= _storage_api_file_log_info($file);
  
  watchdog('storage_api', $message, NULL, WATCHDOG_NOTICE, $link);

  return $file['file_id'];
}


function _storage_api_file_log_info($file) {

  $info = $file['module'] ? ('module: ' . $file['module'] . ', ') : '';
  $info .= $file['type'] ? ('type: ' . $file['type'] . ', ') : '';
  $info .= 'class: ' . $file['name'] . ', <br />';
  
  $info .= 'file_id: ' . $file['file_id'];
  $info .= $file['object_id'] ? (', object_id: ' . $file['object_id']) : '';
  $info .= $file['size'] ? (', size: ' . storage_api_format_size($file['size'])) : '';

  return $info;
}


function _storage_api_container_log_info($container) {

  $info = 'container: ' . $container['name'] . ', <br />';

  return $info;
}


function _storage_api_object_log_info($file) {

  $info = 'object_id: ' . $file['object_id'] . ', ';
  $info .= 'size: ' . storage_api_format_size($file['size']);

  return $info;
}


function _storage_api_acquire_from_url($url) {

  $filepath = tempnam(file_directory_temp(), '');
  $fp = fopen($filepath, "w");

  $options = array(
    CURLOPT_FOLLOWLOCATION => TRUE,
    CURLOPT_AUTOREFERER => TRUE,
    CURLOPT_CONNECTTIMEOUT => 30,
    CURLOPT_LOW_SPEED_LIMIT => 256,
    CURLOPT_LOW_SPEED_TIME => 60,
    CURLOPT_FILE => $fp
  );

  $ch = curl_init(str_replace(' ', '+', $url));   // this seems to keep everyone happy
  curl_setopt_array($ch, $options);
  $result = curl_exec($ch);
  fclose ($fp);
  $info = curl_getinfo($ch);
  curl_close($ch);
  
  switch((int)($info['http_code'] / 100)) {
  
    case 2:
      return $filepath;
      
    case 4:
      @unlink($filepath);
      return FALSE;         // hard failure
      
    default:
      @unlink($filepath);
      return NULL;          // soft failure
  }
}


function _storage_api_delete_object_if_unrequired($object_id) {
  $txn = db_transaction();
  
  // do any files use this object?
  
  if(db_select('storage_file')
    ->condition('object_id', $object_id)
    ->countQuery()
    ->execute()
    ->fetchField())
  {
    return;
  }
  
  db_delete('storage_object')
    ->condition('object_id', $object_id)
    ->execute();
}


function _storage_api_acquire_from_source_url(&$file) {

  if(REQUEST_TIME < $file['data']['next_acquire_time'])
    return;
    
  $filepath = _storage_api_acquire_from_url($file['source_url']);
  
  if($filepath) {
    $object_id = _storage_api_get_object_id($filepath, $new_object);

    if(!$file['object_id']) {
      $file['object_id'] = $object_id;
    }
    
    if($file['object_id'] != $object_id) {    // the file has changed

      _storage_api_delete_object_if_unrequired($object_id);
      @unlink($filepath);
      $filepath = FALSE;
    }
    else {
      unset($file['data']['next_acquire_time']);
      unset($file['data']['next_acquire_delay']);

      $update = array(
        'file_id' => $file['file_id'],
        'object_id' => $file['object_id'],
        'obtained' => REQUEST_TIME,
        'data' => $file['data'],
      );
      
      drupal_write_record('storage_file', $update, 'file_id');
      
      // we need to reload $file to get the filesize, etc
      $file = storage_api_file_load($file['file_id'], TRUE);
      $file['new_object'] = $new_object;    // _storage_api_ensure_instance_exists() will make use of this

      $message = 'Acquired file from url: ' . $file['source_url'] . ' . <br />';
      $message .= _storage_api_file_log_info($file);
      
      $link = $file['nid'] ? l(t('view'), 'node/' . $file['nid']) : NULL;
    
      watchdog('storage_api', $message, NULL, WATCHDOG_NOTICE, $link);

      return $filepath;
    }
  }
  
  if($filepath === FALSE) {   // hard failure

    unset($file['data']['next_acquire_time']);
    unset($file['data']['next_acquire_delay']);

    $update = array(
      'file_id' => $file['file_id'],
      'source_url' => '',
      'data' => $file['data'],
    );
    
    drupal_write_record('storage_file', $update, 'file_id');

    $message = 'Failed acquiring file from url: ' . $file['source_url'] . ' . <br />';
    $message .= _storage_api_file_log_info($file);
    
    $link = $file['nid'] ? l(t('view'), 'node/' . $file['nid']) : NULL;
    
    watchdog('storage_api', $message, NULL, WATCHDOG_WARNING, $link);

    return FALSE;
  }
  
  
  // soft failure
  
  if($file['data']['next_acquire_time']) {
  
    $file['data']['next_acquire_time'] += $file['data']['next_acquire_delay'];
    $file['data']['next_acquire_delay'] *= 2;
  }
  else {
    $file['data']['next_acquire_time'] = REQUEST_TIME + 60;
    $file['data']['next_acquire_delay'] = 120;
  }
  
  $update = array(
    'file_id' => $file['file_id'],
    'data' => $file['data'],
  );
  
  drupal_write_record('storage_file', $update, 'file_id');
}


/**
 * Get a filepath that can be used to access a file locally.
 *
 * The file will be made available locally (this may involve downloading it or generating it). If $keep_me is set to TRUE, then the filepath must not be deleted / modified. If it is set to FALSE, then it must be deleted with unlink() after use.
 *
 * @param $file
 *   File to accessed locally.
 * @param $keep_me
 *   Variable to receive the keep_me status of the returned filepath.
 * @return
 *   A filepath where the file can be accessed.
 */
function storage_api_get_local_filepath(&$file, &$keep_me) {

  $objects_subquery = db_select('storage_object_instance');
  $objects_subquery->join('storage_class_container', NULL, 'storage_object_instance.container_id = storage_class_container.container_id');
  $objects_subquery->join('storage_selector', NULL, 'storage_class_container.class_id = storage_selector.class_id');
  $objects_subquery->join('storage_container', NULL, 'storage_object_instance.container_id = storage_container.container_id');
  $objects_subquery->join('storage_service', NULL, 'storage_object_instance.service_id = storage_service.service_id');
  
  $objects_subquery->condition('storage_object_instance.object_id', $file['object_id'])
    ->condition('storage_class_container.serving', 1, '>=')
    ->condition('storage_selector.selector_id', $file['selector_id'])
    ->condition('storage_container.suspended', 0)
    ->condition('storage_service.suspended', 0)
    ->fields('storage_container')
    ->fields('storage_class_container', array('weight'))
    ->fields('storage_selector', array('migrating'));
    
  $objects_subquery->addExpression('\'object\'', 'type');


  $files_subquery = db_select('storage_file_instance');
  $files_subquery->join('storage_class_container', NULL, 'storage_file_instance.container_id = storage_class_container.container_id');
  $files_subquery->join('storage_selector', NULL, 'storage_class_container.class_id = storage_selector.class_id');
  $files_subquery->join('storage_container', NULL, 'storage_file_instance.container_id = storage_container.container_id');
  $files_subquery->join('storage_service', NULL, 'storage_file_instance.service_id = storage_service.service_id');
  
  $files_subquery->condition('storage_file_instance.file_id', $file['file_id'])
    ->condition('storage_class_container.serving', 1, '>=')
    ->condition('storage_selector.selector_id', $file['selector_id'])
    ->condition('storage_container.suspended', 0)
    ->condition('storage_service.suspended', 0)
    ->fields('storage_container')
    ->fields('storage_class_container', array('weight'))
    ->fields('storage_selector', array('migrating'));
    
  $files_subquery->addExpression('\'file\'', 'type');
    
  $container = $objects_subquery->union($files_subquery, 'ALL')
    ->orderBy('migrating')
    ->orderBy('weight DESC')
    ->orderBy('container_id')
    ->range(0, 1)
    ->execute()
    ->fetchAssoc();
  
  if($container) {
  
    $container['settings'] = unserialize($container['settings']);

    switch($container['type']) {
    
      case 'object':
        $filepath = _storage_api_service_invoke($container['service_id'], 'object_instance_get_filepath', 
          $container, $file);
        break;
      
      case 'file':
        $filepath = _storage_api_service_invoke($container['service_id'], 'file_instance_get_filepath', 
          $container, $file);
        break;
    }

    $service_info = _storage_api_service_invoke($container['service_id'], 'service_info');
    $keep_me = $service_info['local'];
    
    return $filepath;
  }
  
  if($file['source_url']) {

    $filepath = _storage_api_acquire_from_source_url($file);

    if($filepath) {
      return $filepath;
    }
  }

  if($file['module']) {

    $filepath = module_invoke($file['module'], 'storage_file_generate', $file);
    
    $object_id = _storage_api_get_object_id($filepath, $new_object);
    
    if(!$object_id) {
      @unlink($filepath);
      return FALSE;
    }

    if(!$file['object_id'])
      $file['object_id'] = $object_id;
    
    if($file['object_id'] != $object_id) {    // the file has changed

      _storage_api_delete_object_if_unrequired($object_id);
      @unlink($filepath);
      return FALSE;
    }

    $update = array(
      'file_id' => $file['file_id'],
      'object_id' => $file['object_id'],
      'obtained' => REQUEST_TIME,
    );
    
    drupal_write_record('storage_file', $update, 'file_id');

    // we need to reload $file to get the filesize, etc
    $file = storage_api_file_load($file['file_id'], TRUE);
    $file['new_object'] = $new_object;    // _storage_api_ensure_instance_exists() will make use of this
    
    return $filepath;
  }

  return FALSE;
}


/**
 * Schedule a file for complete removal from the system.
 *
 * All instances of the file will be removed during cron.
 *
 * @param $file_id
 *   file_id of the file to be removed.
 */
function storage_api_file_remove($file_id) {

  if(!$file_id)
    return FALSE;

  $file = storage_api_file_load($file_id);
  
  if(!$file)
    return FALSE;
  
  db_update('storage_file')
    ->fields(array(
      'check_me' => 1,
      'serving_container' => serialize(FALSE),
    ))
    ->expression('selector_id', 'NULL')
    ->condition('file_id', $file_id)
    ->execute();
  
  storage_api_file_flush($file_id);
  
  $message = 'File removed' . ($file['filename'] ? (': ' . $file['filename'] . ' ') : '') . ' <br />';
  $message .= _storage_api_file_log_info($file);
  
  watchdog('storage_api', $message, NULL);
}


/**
 * Generate HTTP headers for serving a specific file.
 *
 * The headers will let the file will be cached for 1 year, so URLs must not ever be reused.
 *
 * @param $file
 *   File to be served.
 * @return
 *   An array of HTTP headers.
 */
function storage_api_http_headers($file) {

  $headers[] = 'Content-Type: ' . $file['mimetype'];
  $headers[] = 'Content-Length: ' . $file['size'];
  $headers[] = 'Content-MD5: ' . base64_encode($file['md5']);
  $headers[] = 'Last-Modified: ' . date(DATE_RFC1123, $file['obtained']);
  $headers[] = 'Cache-control: max-age=' . 60 * 60 * 24 * 365;  // the file will stay fresh for a whole year
  
  if($file['force_download'])
    $headers[] = 'Content-Disposition: attachment; filename="' . $file['filename'] . '"';

  return $headers;
}


/**
 * Output directly the correct HTTP headers for a specific file.
 *
 * @param $file
 *   File to be served.
 */
function storage_api_set_http_headers($file) {

  // unset the headers we don't want (they still get sent unfortunately)

  header('Set-Cookie:');
  header('Expires:');
  
  
  foreach(storage_api_http_headers($file) as $header) {
    header($header);
  }
}


/**
 * Get a file extension that matches a MIME type.
 *
 * @param $mimetype
 *   MIME type the file extension should match.
 * @return
 *   File extension (excluding the dot).
 */
function storage_api_mime_extension($mimetype) {

  $path = drupal_get_path('module', 'storage_api');
  require_once DRUPAL_ROOT . '/' . $path . '/mime_extension.inc';

  return _storage_api_mime_extension($mimetype);
}


/**
 * Add a container to a class and schedule instances to be created.
 *
 * @param $class
 *   Class the container should be added to.
 * @param $container
 *   Container that should be added.
 */
function storage_api_class_add_container($class, $container) {

  db_insert('storage_class_container')
    ->fields(array(
      'class_id' => $class['class_id'],
      'container_id' => $container['container_id'],
    ))
    ->execute();  
  
  $selector_subquery = db_select('storage_selector')
    ->fields('storage_selector', array('selector_id'))
    ->condition('class_id', $class['class_id']);
    
  db_update('storage_file')
    ->fields(array('check_me' => 1))
    ->expression('serving_container', 'NULL')
    ->condition('selector_id', $selector_subquery, 'IN')
    ->execute();

  $message = 'Storage container <i>' . $container['name'] . 
    '</i> has been added to class <i>' . $class['name'] .'</i>.';

  $path = 'admin/config/media/storage/classes/' . $class['class_id'];  
  
  drupal_set_message($message);
  watchdog('storage_api', $message, NULL, WATCHDOG_NOTICE, l(t('view'), $path));
}


/**
 * Remove a container from all classes and schedule instances to be destroyed.
 *
 * @param $container
 *   Container to be drained.
 */
function storage_api_drain_container($container) {

  $selector_subquery = db_select('storage_class_container');
  $selector_subquery->join('storage_selector', NULL, 'storage_class_container.class_id = storage_selector.class_id');
  
  $selector_subquery->fields('storage_selector', array('selector_id'))
    ->condition('storage_class_container.container_id', $container['container_id']);
    
  db_update('storage_file')
    ->fields(array('check_me' => 1))
    ->expression('serving_container', 'NULL')
    ->condition('selector_id', $selector_subquery, 'IN')
    ->execute();

  db_delete('storage_class_container')
    ->condition('container_id', $container['container_id'])
    ->execute();

  $message = 'Storage container <i>' . $container['name'] . 
    '</i> has been removed from all classes and will be drained during cron.';

  $path = 'admin/config/media/storage/containers/' . $container['container_id'];
  
  drupal_set_message($message);
  watchdog('storage_api', $message, NULL, WATCHDOG_NOTICE, l(t('view'), $path));
}


function _storage_api_bcmath() {

  // crappy bcmath replacements

  if(!function_exists('bcdiv'))
  {
    function bcdiv($left_operand, $right_operand, $scale = 0)
    {
      return round($left_operand / $right_operand, $scale);
    }
  }

  if(!function_exists('bccomp'))
  {
    function bccomp($left_operand, $right_operand, $scale = 0)
    {
      if($left_operand == $right_operand)
        return 0;
        
      if($left_operand > $right_operand)
        return 1;
        
      return -1;
    }
  }
}


/**
 * Format a byte count to make it easy to read.
 *
 * See http://en.wikipedia.org/wiki/Kilobyte .
 *
 * @param $count
 *   Byte count to be formatted.
 * @return
 *   Formatted size.
 */
function storage_api_format_size($count) {
  _storage_api_bcmath();

  if(bccomp($count, 1000) < 0) {
    return format_plural((int)$count, '1 byte', '@count bytes');
  }
  
  $count = bcdiv($count, 1000, 2);
  $u = 0;
  
  while(bccomp($count, 1000) >= 0) {

    $count = bcdiv($count, 1000, 2);
    $u++;
  }

  $units = array('kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB');
  
  return $count . ' ' . $units[$u];
}


/**
 * Implement hook_theme() .
 */
function storage_api_theme($existing, $type, $theme, $path) {

  return array(
    'storage_api_class_edit_form' => array(
      'render element' => 'form',
    ),
  );
}


/**
 * Implement hook_form_alter() .
 */
function storage_api_form_alter(&$form, $form_state, $form_id) {

  switch($form_id) {
  
    case 'system_modules':

      $form['#submit'][] = '_storage_api_update_services';
      break;
  }
}


/**
 * Implement hook_enable() .
 */
function storage_api_enable() {

  // in case the service modules are enabled simultaneously as the form_alter above wont have taken affect

  _storage_api_update_services();
}

