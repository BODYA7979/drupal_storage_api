<?php
// $Id$

// Copyright 2008-2010 Jonathan Brown


define('STORAGE_API_STORAGE_ONLY', 0);
define('STORAGE_API_SERVING', 1);
define('STORAGE_API_ACCESS_CONTROL', 2);

$path = drupal_get_path('module', 'storage_api');
require_once DRUPAL_ROOT . '/' . $path . '/service.inc';
require_once DRUPAL_ROOT . '/' . $path . '/container.inc';
require_once DRUPAL_ROOT . '/' . $path . '/class.inc';
require_once DRUPAL_ROOT . '/' . $path . '/storage.inc';


/**
 * Implement hook_permission() .
 */
function storage_api_permission() {

  return array('administer storage' => array(
    'title' => t('Administer storage'),
//    'description' => t(''),
  ));
}


/**
 * Implements hook_menu().
 */
function storage_api_menu() {

  $items['system/storage/serve/%storage'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'storage_serve',
    'page arguments' => array(3),
    'access callback' => 'storage_access',
    'access arguments' => array(3),
  );
  

  $items['admin/structure/storage'] = array(
    'title' => 'Storage',
    'access arguments' => array('administer storage'),
    'description' => 'Configure storage.',
    'page callback' => 'system_admin_menu_block_page',
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );


  $items['admin/structure/storage/services'] = array(
    'title' => 'Services',
    'description' => 'Configure storage services.',
    'access arguments' => array('administer storage'),
    'page callback' => 'storage_services',
    'weight' => 0,
    'file' => 'service.admin.inc',
  );
  
  $items['admin/structure/storage/services/%storage_service'] = array(
    'access arguments' => array('administer storage'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_service_form', 4),
    'file' => 'service.admin.inc',
  );
  
  $items['admin/structure/storage/services/%storage_service/suspend'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_service_suspend_form', 4),
    'file' => 'service.admin.inc',
  );
  
  $items['admin/structure/storage/services/%storage_service/unsuspend'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_service_unsuspend_form', 4),
    'file' => 'service.admin.inc',
  );
  
  
  $items['admin/structure/storage/containers'] = array(
    'title' => 'Containers',
    'description' => 'Configure storage containers.',
    'access arguments' => array('administer storage'),
    'page callback' => 'storage_containers',
    'weight' => 1,
    'file' => 'container.admin.inc',
  );
  
  $items['admin/structure/storage/containers/create'] = array(
    'title' => 'Create a container',
    'access arguments' => array('administer storage'),
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_create_container_form'),
    'weight' => 1,
    'file' => 'container.admin.inc',
  );
  
  $items['admin/structure/storage/containers/%storage_container'] = array(
    'access arguments' => array('administer storage'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_container_form', 4),
    'file' => 'container.admin.inc',
  );
  
  $items['admin/structure/storage/containers/%storage_container/view'] = array(
    'title' => 'View',
    'access arguments' => array('administer storage'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
    'file' => 'container.admin.inc',
  );
  
  $items['admin/structure/storage/containers/%storage_container/suspend'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_container_suspend_form', 4),
    'file' => 'container.admin.inc',
  );
  
  $items['admin/structure/storage/containers/%storage_container/unsuspend'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_container_unsuspend_form', 4),
    'file' => 'container.admin.inc',
  );
  
  $items['admin/structure/storage/containers/%storage_container/drain'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_container_drain_form', 4),
    'file' => 'container.admin.inc',
  );

  $items['admin/structure/storage/containers/%storage_container/destroy'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_container_destroy_form', 4),
    'file' => 'container.admin.inc',
  );
  
  $items['admin/structure/storage/containers/%storage_container/edit'] = array(
    'title' => 'Edit',
    'access arguments' => array('administer storage'),
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_container_edit_form', 4),
    'weight' => 1,
    'file' => 'container.admin.inc',
  );

  
  $items['admin/structure/storage/classes'] = array(
    'title' => 'Classes',
    'description' => 'Configure storage classes.',
    'access arguments' => array('administer storage'),
    'page callback' => 'storage_classes_list',
    'weight' => 2,
    'file' => 'class.admin.inc',
  );

  $items['admin/structure/storage/classes/list'] = array(
    'title' => 'Overview',
    'access arguments' => array('administer storage'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
    'file' => 'class.admin.inc',
  );

  $items['admin/structure/storage/classes/create'] = array(
    'title' => 'Create',
    'access arguments' => array('administer storage'),
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_create_class_form'),
    'weight' => 1,
    'file' => 'class.admin.inc',
  );

  $items['admin/structure/storage/classes/%storage_class'] = array(
    'access arguments' => array('administer storage'),
    'page callback' => 'storage_class',
    'page arguments' => array(4),
    'file' => 'class.admin.inc',
  );
  
  $items['admin/structure/storage/classes/%storage_class/view'] = array(
    'title' => 'View',
    'access arguments' => array('administer storage'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
    'file' => 'class.admin.inc',
  );
  
  $items['admin/structure/storage/classes/%storage_class/edit'] = array(
    'title' => 'Edit',
    'access arguments' => array('administer storage'),
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_class_edit_form', 4),
    'weight' => 1,
    'file' => 'class.admin.inc',
  );
  
  $items['admin/structure/storage/classes/%storage_class/destroy'] = array(
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_class_destroy_form', 4),
    'file' => 'class.admin.inc',
  );
  
  $items['admin/structure/storage/classes/%storage_class/add'] = array(
    'title' => 'Add container',
    'access arguments' => array('administer storage'),
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_class_add_container_form', 4),
    'weight' => 2,
    'file' => 'class.admin.inc',
  );
  
  $items['admin/structure/storage/classes/%storage_class/remove/%storage_container'] = array(
    'title' => 'Remove container',
    'access arguments' => array('administer storage'),
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('storage_class_remove_container_form', 4, 6),
    'file' => 'class.admin.inc',
  );

  return $items;
}


/**
 * Loads a storage.
 *
 * @param $storage_id
 *   The storage_id of the storage to be loaded.
 * @return
 *   The storage.
 */
function storage_load($storage_id) {

  try {
    return new Storage($storage_id);
  }
  catch (Exception $e) {
    return FALSE;
  }
}


/**
 * Loads a storage service.
 *
 * @param $srvice_id
 *   The service_id of the service to be loaded.
 * @return
 *   The service.
 */
function storage_service_load($service_id) {

  $fields = db_select('storage_service')
    ->fields('storage_service')
    ->condition('service_id', $service_id)
    ->execute()
    ->fetchAssoc();

  if (!$fields) {
    return FALSE;
  }

  return new StorageService($fields);
}


/**
 * Loads a storage container.
 *
 * @param $container_id
 *   The container_id of the container to be loaded.
 * @return
 *   The container.
 */
function storage_container_load($container_id) {

  $fields = db_select('storage_container')
    ->fields('storage_container')
    ->condition('container_id', $container_id)
    ->execute()
    ->fetchAssoc();

  if (!$fields) {
    return FALSE;
  }
  
  return storage_container_new($fields);
}


function storage_container_new($fields, $unserialize = TRUE) {

  if ($unserialize) {
    $fields['settings'] = unserialize($fields['settings']);
  }
  
  $class = storage_container_class($fields['service_id']);
  return new $class($fields);
}


/**
 * Loads a storage class.
 *
 * @param $class_id
 *   The class_id of the class to be loaded.
 * @return
 *   The class.
 */
function storage_class_load($class_id) {

  try {
    return new StorageClass($class_id);
  }
  catch (Exception $e) {
    return FALSE;
  }
}


function storage_api_storage_services() {

  $services = array(
    'db' => array(
      'name' => t('Database'),
      'class' => 'StorageDB',
      'local' => FALSE,
      'direct' => TRUE,
      'can_copy' => FALSE,
    ),
    'fs' => array(
      'name' => t('Filesystem'),
      'class' => 'StorageFS',
      'local' => TRUE,
      'direct' => FALSE,
      'can_copy' => FALSE,
    ),
    'ftp' => array(
      'name' => t('FTP'),
      'class' => 'StorageFTP',
      'local' => FALSE,
      'direct' => FALSE,
      'can_copy' => FALSE,
    ),
    'rackspace' => array(
      'name' => t('Rackspace Cloud Files'),
      'class' => 'StorageRackspace',
      'local' => FALSE,
      'direct' => FALSE,
      'can_copy' => FALSE,
    ),
    's3_cloudfront' => array(
      'name' => t('Amazon S3 / CloudFront'),
      'class' => 'StorageS3CloudFront',
      'local' => FALSE,
      'direct' => FALSE,
      'can_copy' => TRUE,
    ),
  );

  return $services;
}


function storage_service_info($service_id = NULL) {

  $services = module_invoke_all('storage_services');
  
  if (empty($service_id)) {
    return $services;
  }
  else {
    return $services[$service_id];
  }
}


function storage_container_class($service_id) {

  $info = storage_service_info($service_id);
  return $info['class'];
}


function storage_serve(Storage $storage) {
  $storage->serve();
}

/**
 * Determine whether the user has access to a storage.
 *
 * @param $storage
 *   The storage that access is being checked for.
 * @return
 *   Boolean TRUE if the current user has access to the storage.
 */
function storage_access(Storage $storage) {
  return $storage->access();
}


function _storage_service_unavailable() {
  drupal_add_http_header('503 Service Unavailable');
  watchdog('service unavailable', check_plain($_GET['q']), NULL, WATCHDOG_WARNING);

  // Keep old path for reference.
  if (!isset($_REQUEST['destination'])) {
    $_REQUEST['destination'] = $_GET['q'];
  }

  $path = drupal_get_normal_path(variable_get('site_503', ''));
  if ($path && $path != $_GET['q']) {
    // Custom 503 handler. Set the active item in case there are tabs to
    // display, or other dependencies on the path.
    menu_set_active_item($path);
    $return = menu_execute_active_handler($path, FALSE);
  }

  if (empty($return) || $return == MENU_NOT_FOUND || $return == MENU_ACCESS_DENIED) {
    drupal_set_title(t('Service unavailable'), PASS_THROUGH);
    $return = t('The requested page is not currently available.');
  }
  
  print drupal_render_page($return);
}


/**
 * Creates a new class selector.
 *
 * @return
 *   The selector_id of the new class selector.
 */
function storage_new_selector_id() {
  $txn = db_transaction();

  $class_id = db_select('storage_class')
    ->fields('storage_class', array('class_id'))
    ->orderBy('name')
    ->orderBy('class_id')
    ->range(0, 1)
    ->execute()
    ->fetchField();

  $selector = array('class_id' => $class_id);
  drupal_write_record('storage_selector', $selector);
  
  return $selector['selector_id'];
}


/**
 * Generates a FAPI select element for a class selector.
 *
 * After form submission, pass the form value for the element to storage_selector_submit() .
 *
 * @param $selector_id
 *   The selector_id of the selector the element is for.
 * @param $title
 *   The title of the select element.
 * @param $description
 *   The description of the select element (optional).
 * @return
 *   The select element.
 */
function storage_selector_item($selector_id, $title, $description = NULL) {
  
  $selector = array(
    '#tree' => TRUE
  );
  
  $result = db_select('storage_class', NULL, array('fetch' => PDO::FETCH_ASSOC))
    ->fields('storage_class')
    ->orderBy('name')
    ->orderBy('class_id')
    ->execute();
  
  $classes = array();

  foreach ($result as $class) {
    $classes[$class['class_id']] = $class['name'];
  }
  
  $selector['class_id'] = array(
    '#type' => 'select',
    '#title' => $title,
    '#description' => $description,
    '#options' => $classes
  );
  
  $selector['selector_id'] = array(
    '#type' => 'value',
    '#value' => $selector_id
  );

  $current_class_id = db_select('storage_selector')
    ->fields('storage_selector', array('class_id'))
    ->condition('selector_id', $selector_id)
    ->condition('migrating', 0)
    ->execute()
    ->fetchField();

  $selector['class_id']['#default_value'] = $current_class_id;
  
  $selector['current_class_id'] = array(
    '#type' => 'value',
    '#value' => $current_class_id
  );
  
  return $selector;
}


/**
 * Processes a class selector FAPI element.
 *
 * The element's class selector is updated to point at the class selected. Migration of files to the new class is initiated.
 *
 * @param $form_item
 *   The form value of a submitted class selector FAPI element.
 */
function storage_selector_submit($form_item) {

  if ($form_item['current_class_id'] == $form_item['class_id'])
    return;


  db_merge('storage_selector')
    ->key(array(
      'selector_id' => $form_item['selector_id'],
      'class_id' => $form_item['class_id'],
    ))
    ->fields(array('migrating' => 0))
    ->execute();

  
  // are there any files to migrate?

  $num_files = db_select('storage')
    ->condition('selector_id', $form_item['selector_id'])
    ->countQuery()
    ->execute()
    ->fetchField();
  
  if ($num_files) {

    db_merge('storage_selector')
      ->key(array(
        'selector_id' => $form_item['selector_id'],
        'class_id' => $form_item['current_class_id'],
      ))
      ->fields(array('migrating' => 1))
      ->execute();

    db_update('storage')
      ->fields(array('check_me' => 1))
      ->expression('serving_container', 'NULL')
      ->condition('selector_id', $form_item['selector_id'])
      ->execute();
    
    $new_class = new StorageClass($form_item['class_id']);
    
    $message = 'Migrating ' . $num_files . ' ' . format_plural($num_files, 'file', 'files');
    $message .= ' to storage class <i>' . $new_class->name() . '</i>.';
    
    drupal_set_message($message);
    watchdog('storage_api', $message, NULL);
  }
  else {
  
    db_delete('storage_selector')
      ->condition('selector_id', $form_item['selector_id'])
      ->condition('class_id', $form_item['current_class_id'])
      ->execute();
  }
}


/**
 * Deletes a class selector.
 *
 * @param $selector_id
 *   The selector_id of the selector to be deleted.
 */
function storage_selector_delete($selector_id) {
  
  db_delete('storage_selector')
    ->condition('selector_id', $selector_id)
    ->execute();
}


function _storage_get_selector_initial_container($selector_id) {

  $class_id = db_select('storage_selector')
    ->fields('storage_selector', array('class_id'))
    ->condition('selector_id', $selector_id)
    ->condition('migrating', 0)
    ->execute()
    ->fetchField();

  $class = new StorageClass($class_id);

  return $class->initial_container;
}


function storage_file_id($filename, $size, $md5, $mimetype, &$new_file = NULL) {
  $txn = db_transaction();
  
  $file_id = db_select('storage_file')
    ->fields('storage_file', array('file_id'))
    ->condition('filename', $filename)
    ->condition('size', $size)
    ->condition('md5', $md5)
    ->execute()
    ->fetchField();

  if (!$file_id) {
  
    $file = array(
      'filename' => $filename,
      'size' => $size,
      'md5' => $md5,
      'mimetype' => $mimetype,
    );

    drupal_write_record('storage_file', $file);

    $file_id = $file['file_id'];
    $new_file = TRUE;
  }
  
  return $file_id;
}


function _storage_file_id($filepath, $filename, &$new_file = NULL) {
  $txn = db_transaction();

  $fileinfo = @stat($filepath);
  
  if (!$fileinfo)
    return FALSE;

  $md5 = hash_file('md5', $filepath, TRUE);
  
  return storage_file_id($filename, $fileinfo['size'], $md5, 
    mimedetect_mime(array('filepath' => $filepath, 'filename' => $filename)), $new_file);
}


function _storage_acquire_from_url($url) {

  $filepath = tempnam(file_directory_temp(), '');
  $fp = fopen($filepath, "w");

  $options = array(
    CURLOPT_FOLLOWLOCATION => TRUE,
    CURLOPT_AUTOREFERER => TRUE,
    CURLOPT_CONNECTTIMEOUT => 30,
    CURLOPT_LOW_SPEED_LIMIT => 256,
    CURLOPT_LOW_SPEED_TIME => 60,
    CURLOPT_FILE => $fp
  );

  $ch = curl_init(str_replace(' ', '+', $url));   // this seems to keep everyone happy
  curl_setopt_array($ch, $options);
  $result = curl_exec($ch);
  fclose ($fp);
  $info = curl_getinfo($ch);
  curl_close($ch);
  
  switch ((int)($info['http_code'] / 100)) {
  
    case 2:
      return $filepath;
      
    case 4:
      @unlink($filepath);
      return FALSE;         // hard failure
      
    default:
      @unlink($filepath);
      return NULL;          // soft failure
  }
}


function _storage_delete_file_if_unrequired($file_id) {
  $txn = db_transaction();
  
  // do any storages use this file?
  
  if (db_select('storage')
    ->condition('file_id', $file_id)
    ->countQuery()
    ->execute()
    ->fetchField())
  {
    return;
  }
  
  db_delete('storage_file')
    ->condition('file_id', $file_id)
    ->execute();
}


/**
 * Get a file extension that matches a MIME type.
 *
 * @param $mimetype
 *   MIME type the file extension should match.
 * @return
 *   File extension (excluding the dot).
 */
function storage_mime_extension($mimetype) {

  $path = drupal_get_path('module', 'storage_api');
  require_once DRUPAL_ROOT . '/' . $path . '/mime_extension.inc';

  return _storage_mime_extension($mimetype);
}


function _storage_get_service_names() {

  foreach (module_invoke_all('storage_services') as $service_id => $info)
    $names[$service_id] = $info['name'];
    
  asort($names);
  
  return $names;
}


function _storage_get_service_name($service_id, $link = FALSE) {

  $services = module_invoke_all('storage_services');

  $info = $services[$service_id];
  
  if ($link)
    return l($info['name'], 'admin/structure/storage/services/' . $service_id);
  else
    return $info['name'];
}


function _storage_bcmath() {

  // crappy bcmath replacements

  if (!function_exists('bcdiv'))
  {
    function bcdiv($left_operand, $right_operand, $scale = 0)
    {
      return round($left_operand / $right_operand, $scale);
    }
  }

  if (!function_exists('bccomp'))
  {
    function bccomp($left_operand, $right_operand, $scale = 0)
    {
      if ($left_operand == $right_operand)
        return 0;
        
      if ($left_operand > $right_operand)
        return 1;
        
      return -1;
    }
  }
}


/**
 * Format a byte count to make it easy to read.
 *
 * See http://en.wikipedia.org/wiki/Kilobyte .
 *
 * @param $count
 *   Byte count to be formatted.
 * @return
 *   Formatted size.
 */
function storage_format_size($count) {
  _storage_bcmath();

  if (bccomp($count, 1000) < 0) {
    return format_plural((int)$count, '1 byte', '@count bytes');
  }
  
  $count = bcdiv($count, 1000, 2);
  $u = 0;
  
  while(bccomp($count, 1000) >= 0) {

    $count = bcdiv($count, 1000, 2);
    $u++;
  }

  $units = array('kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB');
  
  return $count . ' ' . $units[$u];
}


/**
 * Implement hook_theme() .
 */
function storage_api_theme($existing, $type, $theme, $path) {

  return array(
    'storage_class_edit_form' => array(
      'render element' => 'form',
    ),
    'storage_info_table' => array(
      'render element' => 'info',
    ),
  );
}


function theme_storage_info_table($variables) {
  $rows = array();

  foreach ($variables['info'] as $key => $value) {
    $rows[] = array(
      array(
        'data' => $key . ':',
        'style' => 'font-weight: bold',
      ),
      $value,
    );
  }
  
  return '<p>' . theme('table', array(
    'rows' => $rows, 
    'attributes' => array('style' => 'width: auto;')
  )) . '</p>';
}


function _storage_update_services() {

  $code_service_ids = array_keys(module_invoke_all('storage_services'));

  $result = db_select('storage_service', NULL, array('fetch' => PDO::FETCH_ASSOC))
    ->fields('storage_service', array('service_id'))
    ->execute();

  $db_service_ids = array();

  foreach ($result as $service) {

    if (!in_array($service['service_id'], $code_service_ids)) {

      db_delete('storage_service')
        ->condition('service_id', $service['service_id'])
        ->execute();
    }
    else {
      $db_service_ids[] = $service['service_id'];
    }
  }
  
  
  foreach ($code_service_ids as $service_id) {
  
    if (!in_array($service_id, $db_service_ids)) {
    
      db_insert('storage_service')
        ->fields(array(
          'service_id' => $service_id,
        ))
        ->execute();  
    }
  }
}  


/**
 * Implement hook_modules_enabled() .
 */
function storage_api_modules_enabled($modules) {

  _storage_update_services();
}


/**
 * Implement hook_modules_disabled() .
 */
function storage_api_modules_disabled($modules) {

  _storage_update_services();
}


function storage_api_new_local_storage_path() {

  return file_create_filename('storage', conf_path());
}


/**
 * Implement hook_cron() .
 */
function storage_api_cron() {

  $path = drupal_get_path('module', 'storage_api');
  require_once DRUPAL_ROOT . '/' . $path . '/cron.inc';

  _storage_api_cron();
}

