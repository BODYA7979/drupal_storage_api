<?php

// Copyright 2010-2011 Jonathan Brown


function storage_core_bridge_field_selector($field_name) {

  return storage_selector('storage_core_bridge', 'field:' . $field_name);
}


function storage_core_bridge_image_style_selector($isid = 'null') {

  return storage_selector('storage_core_bridge', 'image_style:' . $isid);
}


function storage_core_bridge_field_selector_create($field_name) {

  storage_core_bridge_field_selector($field_name)->create();

  $fields = variable_get('storage_core_bridge_fields');
  $fields[] = $field_name;
  variable_set('storage_core_bridge_fields', $fields);
}


function storage_core_bridge_field_selector_destroy($field_name) {

  storage_core_bridge_field_selector($field_name)->destroy();

  $fields = variable_get('storage_core_bridge_fields');

  foreach ($fields as $key => $name) {
    if ($name == $field_name) {
      unset($fields[$key]);
    }
  }

  variable_set('storage_core_bridge_fields', $fields);
}


/**
 * Implements hook_field_create_field().
 */
function storage_core_bridge_field_create_field(array $field) {

  if (in_array($field['type'], array('file', 'image'))) {
    storage_core_bridge_field_selector_create($field['field_name']);
  }
}


/**
 * Implements hook_field_delete_field().
 */
function storage_core_bridge_field_delete_field(array $field) {

  if (in_array($field['type'], array('file', 'image'))) {
    storage_core_bridge_field_selector_destroy($field['field_name']);
  }
}


/**
 * Implements hook_stream_wrappers().
 */
function storage_core_bridge_stream_wrappers() {

  // Work out which selector streamwrapper should be visible.
  if (strpos($_GET['q'], 'admin/structure/types/manage/') === 0 && arg(5) == 'fields') {
    $active_field = arg(6);
  }
  elseif (strpos($_GET['q'], 'admin/structure/taxonomy/') === 0 && arg(4) == 'fields') {
    $active_field = arg(5);
  }
  // If a default image is being uploaded via AJAX then make all selector
  // streamwrappers visible so the form doesn't break.
  elseif (strpos($_GET['q'], 'file/ajax/field/settings/default_image') === 0) {
    $active_field = NULL;
  } else {
    $active_field = FALSE;
  }

  $fields = variable_get('storage_core_bridge_fields');
  $wrappers = array();
  
  foreach ($fields as $field) {

    $wrappers['storage-' . str_replace('_', '-', $field)] = array(
      'name' => t("Storage class (select below)"),
      'class' => 'DrupalStorageStreamWrapper',
      'description' => t("Files managed by Storage API."),
      'type' => (is_null($active_field) || ($field == $active_field)) ? STREAM_WRAPPERS_NORMAL : STREAM_WRAPPERS_HIDDEN,
    );
  }

  return $wrappers;
}


/**
 * Implements hook_image_style_save().
 */
function storage_core_bridge_image_style_save(array $style) {

  if (isset($style['is_new'])) {
    storage_core_bridge_image_style_selector($style['isid'])->create();
  }
}


/**
 * Implements hook_image_style_delete().
 */
function storage_core_bridge_image_style_delete(array $style) {
  storage_core_bridge_image_style_selector($style['isid'])->destroy();
}


/**
 * Implements hook_form_FORM_ID_alter().
 */
function storage_core_bridge_form_image_style_revert_form_alter(array &$form, array &$form_state, $form_id) {
  $form['#submit'][] = 'storage_core_bridge_image_style_revert_form_submit';
}


function storage_core_bridge_image_style_revert_form_submit(array $form, array &$form_state) {
  storage_core_bridge_image_style_selector($form_state['image_style']['isid'])->destroy();
}


/**
 * Implements hook_form_FORM_ID_alter().
 */
function storage_core_bridge_form_field_ui_field_settings_form_alter(array &$form, array &$form_state) {

  if (!in_array($form['field']['type']['#value'], array('file', 'image'))) {
    return;
  }

  $form['field']['settings']['storage_class'] =
    storage_core_bridge_field_selector($form['field']['field_name']['#value'])->formItem();

  $form['field']['settings']['uri_scheme']['#weight'] = -2;
  $form['field']['settings']['storage_class']['#weight'] = -1;

  $form['#submit'][] = 'storage_core_bridge_field_ui_field_settings_form_submit';
}


function storage_core_bridge_field_ui_field_settings_form_submit(array $form, array &$form_state) {

  storage_core_bridge_field_selector($form['field']['field_name']['#value'])
    ->submit($form_state['values']['field']['settings']['storage_class']);
}


/**
 * Implements hook_form_FORM_ID_alter().
 */
function storage_core_bridge_form_field_ui_field_edit_form_alter(array &$form, array &$form_state) {

  if (!in_array($form['#field']['type'], array('file', 'image'))) {
    return;
  }

  $form['field']['settings']['storage_class'] =
    storage_core_bridge_field_selector($form['#field']['field_name'])->formItem();

  $form['field']['settings']['uri_scheme']['#weight'] = -2;
  $form['field']['settings']['storage_class']['#weight'] = -1;

  $form['#submit'][] = 'storage_core_bridge_field_ui_field_edit_form_submit';
}


function storage_core_bridge_field_ui_field_edit_form_submit(array $form, array &$form_state) {

  storage_core_bridge_field_selector($form['#field']['field_name'])
    ->submit($form_state['values']['field']['settings']['storage_class']);
}


function storage_core_bridge_form_image_style_form_alter(array &$form, array &$form_state) {

  $form['storage_api'] = array(
    '#type' => 'fieldset',
    '#title' => t("Storage API"),
    '#description' => t("These settings only apply to styled images which are derived from images managed by Storage API."),
  );

  if ($form_state['image_style']['storage'] & IMAGE_STORAGE_EDITABLE) {
    $form['storage_api']['storage_class'] =
      storage_core_bridge_image_style_selector($form_state['image_style']['isid'])->formItem();
    $form['#submit'][] = 'storage_core_bridge_image_style_form_submit';
  }
  else {
    $form['storage_api']['#disabled'] = TRUE;
    $description = t("As this image style is being provided by a module, the storage class of the source image will also be used for its derived images.");
    $form['storage_api']['storage_class'] = storage_core_bridge_image_style_selector()->formItem(NULL, $description);
  }
}


function storage_core_bridge_image_style_form_submit(array $form, array &$form_state) {

  storage_core_bridge_image_style_selector($form_state['image_style']['isid'])
    ->submit($form_state['values']['storage_api']['storage_class']);
}


function storage_core_bridge_storage_id($uri) {

  $storage_id = db_select('storage')
    ->fields('storage', array('storage_id'))
    ->condition('storage.core_bridge_uri', $uri)
    ->execute()
    ->fetchField();

  if (!$storage_id) {
    throw new StorageException();
  }

  return $storage_id;
}


/**
 * Loads a storage a URI.
 *
 * @param $uri
 *   The URI of the storage to load.
 *
 * @return
 *   The storage.
 *
 * @throws StorageException
 *   When it isn't possible to load the storage.
 */
function storage_core_bridge_load($uri) {

  return storage_load(storage_core_bridge_storage_id($uri));
}


function storage_core_bridge_uri_field_name($uri) {

  return str_replace('-', '_', substr(file_uri_scheme($uri), 8));
}


/**
 * Loads the storage of a styled image from a source URI.
 *
 * @param $uri
 *   The URI of the storage of the source image.
 * @param $style_name
 *   The name of the image style.
 *
 * @return
 *   The storage of a styled image.
 *
 * @throws StorageException
 *   When it isn't possible to load the storage of the styled image.
 */
function storage_core_bridge_styled_image_load($uri, $style_name) {

  $source_id = storage_core_bridge_storage_id($uri);

  $storage_id = db_select('storage_styled_image')
    ->fields('storage_styled_image', array('storage_id'))
    ->condition('storage_styled_image.source_id', $source_id)
    ->condition('storage_styled_image.style', $style_name)
    ->execute()
    ->fetchField();
    
  if ($storage_id) {
    $storage = storage_load($storage_id);
  }
  else {
    $source_storage = storage_load($source_id);

    // Determine the filename of the styled image.
    $components = explode('/', $source_storage->filename);
    $basename = array_pop($components);
    array_push($components, $style_name, $basename);
    $options['filename'] = implode('/', $components);

    // Try to determine the file_id of the styled image. This means
    // deduplication can occur without the image being generated.
    $query = db_select('storage', 'source_storage');
    $query->join('storage_styled_image', NULL, 'source_storage.storage_id = storage_styled_image.source_id');
    $query->join('storage', NULL, 'storage_styled_image.storage_id = storage.storage_id');

    $file_id = $query->condition('source_storage.file_id', $source_storage->file_id)
      ->condition('storage_styled_image.style', $style_name)
      ->fields('storage', array('file_id'))
      ->range(0, 1)
      ->execute()
      ->fetchField();

    if ($file_id) {
      $options['file_id'] = $file_id;
    }

    // Create the storage.
    $style = image_style_load($style_name);

    if ($style['storage'] & IMAGE_STORAGE_EDITABLE) {
      $selector = storage_core_bridge_image_style_selector($style['isid']);
    }
    else {
      $field_name = storage_core_bridge_uri_field_name($uri);
      $selector = storage_core_bridge_field_selector($field_name);
    }

    $storage = $selector->storageAdd($options);

    db_insert('storage_styled_image')
      ->fields(array(
        'source_id' => $source_id,
        'style' => $style_name,
        'storage_id' => $storage->storage_id,
      ))
      ->execute();
  }
  
  return $storage;
}


/**
 * Implements hook_storage_generate().
 */
function storage_core_bridge_storage_generate(Storage $storage) {

  $styled_image = db_select('storage_styled_image')
    ->fields('storage_styled_image')
    ->condition('storage_styled_image.storage_id', $storage->storage_id)
    ->execute()
    ->fetchAssoc();

  $source_storage = storage_load($styled_image['source_id']);

  $style = image_style_load($styled_image['style']);
  $source = $source_storage->getUri();
  $destination = storage_temp_uri();

  image_style_create_derivative($style, $source, $destination);

  return $destination;
}


/**
 * Implements hook_image_style_flush().
 */
function storage_core_bridge_image_style_flush(array $style) {

  $storage_ids = db_select('storage_styled_image')
    ->fields('storage_styled_image', array('storage_id'))
    ->condition('storage_styled_image.style', $style['name'])
    ->execute()
    ->fetchCol();
    
  foreach ($storage_ids as $storage_id) {
    try {
      storage_load($storage_id)->remove();
    }
    catch (StorageException $e) {}
  }

  db_delete('storage_styled_image')
    ->condition('storage_styled_image.style', $style['name'])
    ->execute();
}


function storage_core_bridge_image_delete_derivatives($source_id) {

  $storage_ids = db_select('storage_styled_image')
    ->fields('storage_styled_image', array('storage_id'))
    ->condition('storage_styled_image.source_id', $source_id)
    ->execute()
    ->fetchCol();

  foreach ($storage_ids as $storage_id) {
    try {
      storage_load($storage_id)->remove();
    }
    catch (StorageException $e) {}
  }

  db_delete('storage_styled_image')
    ->condition('storage_styled_image.source_id', $source_id)
    ->execute();
}


class DrupalStorageStreamWrapper implements DrupalStreamWrapperInterface {
  protected $uri;
  protected $mode;
  protected $temp_uri;
  protected $fp;


  /**
   * StreamWrapperInterface methods.
   */

  public function stream_open($uri, $mode, $options, &$opened_url) {
    $this->uri = $uri;
    $this->mode = $mode[0];
    
    switch ($this->mode) {

      case 'w':
        $this->temp_uri = storage_temp_uri();
        $this->fp = fopen($this->temp_uri, 'wb');
        break;

      case 'r':
        $storage = storage_core_bridge_load($uri);
        $this->temp_uri = $storage->getUri();
        $this->fp = fopen($this->temp_uri, 'rb');
        break;
    }
    
    return TRUE;
  }
  
  public function stream_close() {
    global $storage_core_bridge_filename;
    fclose($this->fp);

    if ($this->mode == 'w') {

      $options = array(
        'source_uri' => $this->temp_uri,
        'filename' => $storage_core_bridge_filename,
        'core_bridge_uri' => $this->uri,
      );

      $field_name = storage_core_bridge_uri_field_name($this->uri);

      try {
        $storage = storage_core_bridge_field_selector($field_name)->storageAdd($options);
      }
      catch (StorageException $e) {}
    }
  }
  
  public function stream_read($count) {
    return fread($this->fp, $count);
  }

  public function stream_write($data) {
    return fwrite($this->fp, $data);
  }
  
  public function stream_eof() {
    return feof($this->fp);
  }
  
  public function stream_seek($offset, $whence) {
    // fseek() returns 0 on success and -1 on a failure.
    // stream_seek()   1 on success and  0 on a failure.
    return !fseek($this->fp, $offset, $whence);
  }
  
  public function stream_tell() {
    return ftell($this->fp);
  }
  
  public function stream_stat() {
    return $this->url_stat($this->uri);
  }
  
  public function unlink($uri) {
    $storage = storage_core_bridge_load($uri);
    $storage->remove();
    storage_core_bridge_image_delete_derivatives($storage->storage_id);
    return TRUE;
  }

  public function mkdir($uri, $mode, $options) {
    return TRUE;
  }

  public function url_stat($uri, $flags) {
    global $storage_core_bridge_filename;
    global $storage_core_bridge_dirname;

    // Did we just say in DrupalStorageStreamWrapper::dirname() that this is a
    // directory?
    if ($storage_core_bridge_dirname == $uri) {
      return array('mode' => 0040777);
    }
    
    $filename = file_uri_target($uri);

    if ($storage_core_bridge_filename == '' ||
      (count(explode('/', $filename)) > count(explode('/', $storage_core_bridge_filename))))
    {
      $storage_core_bridge_filename = $filename;
    }

    try {
      $storage = storage_core_bridge_load($uri);
    }
    catch (StorageException $e) {
      return FALSE;
    }

    $stat = array(
      'mode' => 0100666,
      'size' => $storage->size,
      'atime' => $storage->created,
      'mtime' => $storage->created,
      'ctime' => $storage->created,
    );

    return $stat;
  }
  
  
  /**
   * DrupalStreamWrapperInterface methods.
   */

  public function setUri($uri) {
    $this->uri = $uri;
  }

  public function getUri() {
    return $this->uri;
  }
  
  public function getExternalUrl() {
    $components = explode('/', file_uri_target($this->uri));
    $scheme = file_uri_scheme($this->uri);

    try {
      if ((array_shift($components) == 'styles') && ($style = array_shift($components)) && 
        (array_shift($components) == $scheme))
      {
        $storage = storage_core_bridge_styled_image_load($scheme . '://' . implode('/', $components), $style);
      }
      else {
        $storage = storage_core_bridge_load($this->uri);
      }

      return $storage->serveURL(TRUE);
    }
    catch (StorageException $e) {
      return FALSE;
    }
  }
  
  public static function getMimeType($uri, $mapping = NULL) {
    $storage = storage_core_bridge_load($uri);
    return $storage->mimetype;
  }

  public function chmod($mode) {
    return TRUE;
  }

  public function realpath() {
    return $this->uri;
  }

  public function dirname($uri = NULL) {
    global $storage_core_bridge_dirname;

    $scheme = file_uri_scheme($uri);
    $target = file_uri_target($uri);

    $dirname = dirname($target);

    if ($dirname == '.') {
      $dirname = '';
    }

    // Store the dirname in a global variable so that
    // DrupalStorageStreamWrapper::url_stat() knows it is a directory.
    $storage_core_bridge_dirname = $scheme . '://' . $dirname;
    return $storage_core_bridge_dirname;
  }


  /**
   * Unimplemented methods.
   */

  public function stream_lock($operation) {}
  public function stream_flush() {}
  public function rename($from_uri, $to_uri) {}
  public function rmdir($uri, $options) {}
  public function dir_opendir($uri, $options) {}
  public function dir_readdir() {}
  public function dir_rewinddir() {}
  public function dir_closedir() {}
  public function getDirectoryPath() {}
}

